% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/feature_table.R
\name{FeatureTable}
\alias{FeatureTable}
\title{FeatureTable}
\description{
R6 Class for managing feature tables and associated metadata.
}
\details{
For an overview of the package, run \code{?featuretable} at the R console, or use this link: \link{featuretable}.

Each of the methods listed below have extensive documention in their individual help files.  For example, to access detailed documentation for \code{FeatureTable$keep}, run this in the R console: \code{?keep}.  As such, the documentation on this page is intentionally kept light.
}
\examples{

## ------------------------------------------------
## Method `FeatureTable$new`
## ------------------------------------------------

count_table <- matrix(
  c(
    0, 0, 0, 1, 10,
    0, 0, 1, 2, 20,
    0, 1, 2, 3, 30,
    1, 2, 3, 4, 40
  ),
  byrow = TRUE,
  nrow = 4,
  ncol = 5,
  dimnames = list(Samples = paste0("Sample_", 1:4),
                  Features = paste0("Feature_", 1:5))
)

feature_data <- data.frame(
  Color = c("red", "red", "red", "blue", "blue"),
  Shape = c("square", "circle", "square", NA, "circle"),
  Length = c(5, 6, 2.3, 7, 10),
  row.names = paste0("Feature_", 1:5),
  stringsAsFactors = TRUE
)

sample_data <- data.frame(
  Location = c("Spain", "Spain", "Portugal", "Spain"),
  Season = c("Summer", "Summer", "Winter", "Winter"),
  SnazzyFactor = c(10, 12, 25, 3),
  row.names = paste0("Sample_", 1:4),
  stringsAsFactors = TRUE
)

FeatureTable$new(count_table,
                 feature_data = feature_data,
                 sample_data = sample_data)

## ------------------------------------------------
## Method `FeatureTable$print`
## ------------------------------------------------

# `lee` is a dataset included in the FeatureTable package.
featuretable::lee$print()
# it would print out something like this:
# FeatureTable:
#   data         -- 16 samples, 1490 features
#   feature_data -- 7 covariates
#   sample_data  -- 4 covariates


## ------------------------------------------------
## Method `FeatureTable$dim`
## ------------------------------------------------

ft <- FeatureTable$new(matrix(1:12, 3, 4))
stopifnot(ft$dim() == 12)
stopifnot(ft$nrow() == 3)
stopifnot(ft$ncol() == 4)

## ------------------------------------------------
## Method `FeatureTable$max`
## ------------------------------------------------

ft <- FeatureTable$new(matrix(0:8, 3, 3))
stopifnot(ft$min() == 0)
stopifnot(ft$non_zero_min() == 1)
stopifnot(ft$max() == 8)
stopifnot(ft$size() == 9)

## ------------------------------------------------
## Method `FeatureTable$apply`
## ------------------------------------------------

# `ft` is a dataset included in FeatureTable.
#
# The apply method is a convenience wrapper around `base::apply`.
stopifnot(
  featuretable::ft$apply(2, sum) == apply(featuretable::ft$data, 2, sum)
)


## ------------------------------------------------
## Method `FeatureTable$apply_with_index`
## ------------------------------------------------

ft <- featuretable::ft

# `apply_with_index` takes a function of two or more arguments, the first is the data you're working on, the second is the index of that data (e.g., row or column number), and then any other arguments are additional.
ft$apply_with_index(2, function(x, i) sum(x))

# This could of course be written as
ft$apply(2, sum)

stopifnot(
  ft$apply_with_index(2, function(x, i) sum(x)) ==
    ft$apply(2, sum)
)

# But that's a boring example.  Say you had a vector of lengths, one for
# each feature.
lengths <- c(10, 15, 12, 25, 13)

# Now you could weight the sum by the length of that feature.
ft$apply_with_index(2, function(feature, index) {
  sum(feature) / lengths[[index]]
})

# This data (`ft`) happens to have a `Length` column in the `feature_data`
# field.  Let's use that instead.
ft$apply_with_index(2, function(feature, index) {
  sum(feature) / ft$featue_data$Length[[index]]
})


## ------------------------------------------------
## Method `FeatureTable$apply_with_name`
## ------------------------------------------------

ft <- featuretable::ft

# Unlike `apply_with_index`, `fn` takes a name.  Its usage is similar.
ft$apply_with_name(2, function(feature, name) {
  sum(feature) / ft$feature_data[name, "Length"]
})

## ------------------------------------------------
## Method `FeatureTable$map`
## ------------------------------------------------

data(ft)

## Using R6 methods

# Map over features
ft$map("features", function(feature) feature / sum(feature))

# Map over samples
ft$map("samples", function(sample) sample / sum(sample))

## Using s3 methods

# Map over features
map(ft, "features", function(feature) feature / sum(feature))

# Map over samples
map(ft, "samples", function(sample) sample / sum(sample))

#### map_with_index

# Make up some fake lengths for the features.
lengths <- 1:ft$num_features()

# Map over features using the index to divide the feature by its length.
ft$map_with_index("features", function(feature, index) feature / lengths[[index]])

# And of course, the s3 function is also available!
map_with_index(ft, "features", function(feature, index) feature / lengths[[index]])

#### map_with_name

# This FeatureTable includes a \code{Length} variable in the \code{feature_data}.
#
# You can access it like this:
ft$feature_data$Length

# Let's say you want to divide the count of each feature by its length.
#
# To get easy access to that data, you can use map_with_name like so:
ft$map_with_name("features", function(feature, name) {
  feature_length <- ft$feature_data[name, "Length"]

  # Some features have an NA for length, so just set those to 1.
  feature_length <- ifelse(is.na(feature_length), 1, feature_length)

  feature / feature_length
})

# And of course, the s3 function is also available!
map_with_name(ft, "features", function(feature, name) {
  feature_length <- ft$feature_data[name, "Length"]

  # Some features have an NA for length, so just set those to 1.
  feature_length <- ifelse(is.na(feature_length), 1, feature_length)

  feature / feature_length
})


## ------------------------------------------------
## Method `FeatureTable$collapse`
## ------------------------------------------------

data(ft)

# You can direcctly access variables in the metadata.
ft$collapse("features", Color)
ft$collapse_features(Color)

# Or refer to them by strings.
ft$collapse("features", "Color")
ft$collapse_features("Color")

# You can collapse samples on metadata as well.
ft$collapse("samples", Location)
ft$collapse_samples(Location)

# And you can use the s3 style functions.
collapse(ft, "samples", Location)
collapse_samples(ft, Location)

collapse(ft, "features", Shape)
collapse_features(ft, Shape)

# For now, you can't do more than one variable at a time.  Sorry!
\dontrun{
  ft$collapse_samples(c("Location", "Season"))
}


## ------------------------------------------------
## Method `FeatureTable$keep`
## ------------------------------------------------

data(ft)

#### Filtering based on metadata ####

# First, let me show you how to filter based on metadata (i.e., the stuff in
# `$feature_data` or `$sample_data`).  Note that this kind of filtering works
# the same for samples.

# Here is what the `feature_data` looks like.
#
# > ft$feature_data
#           Color  Shape Length
# Feature_1   red square    5.0
# Feature_2   red circle    6.0
# Feature_3   red square    2.3
# Feature_4  blue   <NA>    7.0
# Feature_5  blue circle   10.0

# To keep features, you can use either `keep` and specify the correct margin,
# or use the `keep_features` helper function.  For the examples that follow,
# I will show you both ways, but of course, you can pick whichever one you
# prefer!

# Also note that whenever you see something with the R6 calling convention:
# E.g., ft$keep("features", ...), feel free to use the S3 calling convention
# instead: keep(ft, "features", ...).

# Keep features that have 'circle' in the `feature_data`.  Note that you can
# refer to variables/colnames in the data directly inside the `keep`
# functions!
#
ft$keep("features", Shape == "circle")
ft$keep_features(Shape != "circle")

# You can use a logical vector directly.
#
ft$keep("features", c(TRUE, TRUE, FALSE, TRUE, TRUE))
ft$keep_features(c(TRUE, TRUE, FALSE, TRUE, TRUE))

# Or you can use any expressions that will evaluate to a logical vector.
#
ft$keep("features", ft$feature_data$Shape == "circle")
ft$keep_features(ft$feature_data$Shape == "circle")

# Keep features that do NOT have 'circle' in the `feature_data`.
#
ft$keep("features", Shape != "circle")
ft$keep_features(Shape != "circle")

# You can also have more complicated expressions for predicates.
#
# Keep the red circles
ft$keep("features", Shape == "circle" & Color == "red")
ft$keep_features(Shape == "circle" & Color == "red")

# Keep any features that are 'red' OR 'circles'.
ft$keep("features", Shape == "circle" | Color == "red")
ft$keep_features(Shape == "circle" | Color == "red")

# Of course, you can keep adding on expressions....
ft$keep("features", (Shape == "square" & Color == "red") | Length > 5)
ft$keep_features((Shape == "square" & Color == "red") | Length > 5)

#### Filtering based on actual data (i.e., in `$data`) ####

# Sometimes you want to filter features or samples based on the actual data
# (i.e., the stuff in `$data`), rather than on the metadata (i.e., the stuff
# in `$feature_data` or `$sample_data`).  No problem!  For that, we will use
# functions that apply over the margin we want.

# For reference, here is the data:
#
# > ft$data
#           Features
# Samples    Feature_1 Feature_2 Feature_3 Feature_4 Feature_5
#   Sample_1         0         0         0         1        10
#   Sample_2         0         0         1         2        20
#   Sample_3         0         1         2         3        30
#   Sample_4         1         2         3         4        40

# Keep features whose sum is more than 5.
ft$keep("features", function(feature) sum(feature) > 5)
ft$keep_features(function(feature) sum(feature) > 5)

# Keep samples whose sum is more than 25.
ft$keep("samples", function(sample) sum(sample) > 5)
ft$keep_samples(function(sample) sum(sample) > 5)

# Note that there is nothing special about using `sample` or `feature` as a
# parameter to those anonymous functions.  I could have used `x` or anything
# else.

#### Predicates that work on data and metadata together! ####

# What if you want to filter based on both metadata and the actual data?
# For that, you need to use `query`.  It is a special function only
# accessible from inside the keep functions. (Note that currently, you can
# only use `query` from `keep` with margin 'features', or keep_features.)

# Keep features that are circles and also have an abundance of > 5.
ft$keep("features",
        query(Shape == "circle") & query(function(feature) sum(feature) > 5))
ft$keep_features(
  query(Shape == "circle") & query(function(feature) sum(feature) > 5)
)

# Notice how I wrapped both expressions in a `query` function.  You can also
# have more than two queries just like before.

# One slightly weird thing is that the expression that evalautes w.r.t. the
# metadata doesn't actually need to be wrapped in a query.  For example, this
# will also work:
#
ft$keep_features(
  Shape == "circle" & query(function(feature) sum(feature) > 5)
)

# But I would consider that a quirk of the implementation and not rely on it,
# as it may change in the future.

#### Filtering on actual data, feature data, and sample data together ####

# For reference, here is the sample data:
# > ft$sample_data
#           Location Season SnazzyFactor
#  Sample_1    Spain Summer           10
#  Sample_2    Spain Summer           12
#  Sample_3 Portugal Winter           25
#  Sample_4    Spain Winter            3

# (Note that like the above section, this only works for features currently.)
#
# Here's something cool.  Let's say you wanted to filter features based on
# their abundance, some bit of metadata about them (e.g., taxonomy) but
# restrict your search to a subset of samples (say, all samples from Summer,
# or all samples from Spain).  You can do that with the `query` function as
# well!  Let me show you what I mean....

# Keep features whose abundance is > 5 in 'Winter' samples (i.e., you don't
# care what there abundance in other seasons, as long as they fit the
# criteria for the 'Winter' samples.)

ft$keep("features", query(function(feature) sum(feature) > 5,
                          restrict = Season == "Winter"))

# Notice the use of the `restrict` parameter.  It takes expressions that
# evaluate in the context of the sample data.

# And you can make more complicated queries if you want.
ft$keep_features(query(Shape == "circle") |
                   query(function(feature) sum(feature) > 5,
                         restrict = Season == "Winter"))

# Here is something that may trip you up.

\dontrun{
  ft$keep_features(query(Shape == "circle", restrict = Season == "Winter"))
}

# The above code will raise an `ArgumentError`.  Here's the thing: feature
# metadata does not change based on the sample metadata.  In other words, a
# feature is a 'circle' or a 'square' regardless of whether it is in a
# 'Summer' sample, a 'Winter' sample, or both.  So restricting a metadata
# query to a subset of samples just doesn't make any sense.
#
# If you find yourself wanting to do that, my guess is what you really want
# are to filter features whose 'Shape' is 'circle' and that are actually
# present in 'Winter' samples.  If that is the case, you want to do something
# like this:
#
ft$keep_features(
  query(Shape == "circle") &
    query(function(feature) sum(feature) > 0,
          restrict = Season == "Winter")
)

}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{data}}{The data table with samples/observations as rows and features as columns.}

\item{\code{feature_data}}{Rows are features, columns are stuff about the features.  Not necessarily hierarchical.}

\item{\code{sample_data}}{Rows are samples, columns are things about the samples.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{FeatureTable$new()}}
\item \href{#method-print}{\code{FeatureTable$print()}}
\item \href{#method-dim}{\code{FeatureTable$dim()}}
\item \href{#method-nrow}{\code{FeatureTable$nrow()}}
\item \href{#method-ncol}{\code{FeatureTable$ncol()}}
\item \href{#method-max}{\code{FeatureTable$max()}}
\item \href{#method-min}{\code{FeatureTable$min()}}
\item \href{#method-non_zero_min}{\code{FeatureTable$non_zero_min()}}
\item \href{#method-size}{\code{FeatureTable$size()}}
\item \href{#method-num_samples}{\code{FeatureTable$num_samples()}}
\item \href{#method-nsamples}{\code{FeatureTable$nsamples()}}
\item \href{#method-num_observations}{\code{FeatureTable$num_observations()}}
\item \href{#method-nobservations}{\code{FeatureTable$nobservations()}}
\item \href{#method-num_features}{\code{FeatureTable$num_features()}}
\item \href{#method-nfeatures}{\code{FeatureTable$nfeatures()}}
\item \href{#method-sample_names}{\code{FeatureTable$sample_names()}}
\item \href{#method-observation_names}{\code{FeatureTable$observation_names()}}
\item \href{#method-feature_names}{\code{FeatureTable$feature_names()}}
\item \href{#method-apply}{\code{FeatureTable$apply()}}
\item \href{#method-apply_with_index}{\code{FeatureTable$apply_with_index()}}
\item \href{#method-apply_with_name}{\code{FeatureTable$apply_with_name()}}
\item \href{#method-apply_features}{\code{FeatureTable$apply_features()}}
\item \href{#method-apply_features_with_index}{\code{FeatureTable$apply_features_with_index()}}
\item \href{#method-apply_features_with_name}{\code{FeatureTable$apply_features_with_name()}}
\item \href{#method-apply_samples}{\code{FeatureTable$apply_samples()}}
\item \href{#method-apply_samples_with_index}{\code{FeatureTable$apply_samples_with_index()}}
\item \href{#method-apply_samples_with_name}{\code{FeatureTable$apply_samples_with_name()}}
\item \href{#method-map}{\code{FeatureTable$map()}}
\item \href{#method-map_with_index}{\code{FeatureTable$map_with_index()}}
\item \href{#method-map_with_name}{\code{FeatureTable$map_with_name()}}
\item \href{#method-map_features}{\code{FeatureTable$map_features()}}
\item \href{#method-map_features_with_index}{\code{FeatureTable$map_features_with_index()}}
\item \href{#method-map_features_with_name}{\code{FeatureTable$map_features_with_name()}}
\item \href{#method-map_samples}{\code{FeatureTable$map_samples()}}
\item \href{#method-map_samples_with_index}{\code{FeatureTable$map_samples_with_index()}}
\item \href{#method-map_samples_with_name}{\code{FeatureTable$map_samples_with_name()}}
\item \href{#method-collapse}{\code{FeatureTable$collapse()}}
\item \href{#method-collapse_features}{\code{FeatureTable$collapse_features()}}
\item \href{#method-collapse_samples}{\code{FeatureTable$collapse_samples()}}
\item \href{#method-keep}{\code{FeatureTable$keep()}}
\item \href{#method-keep_features}{\code{FeatureTable$keep_features()}}
\item \href{#method-keep_samples}{\code{FeatureTable$keep_samples()}}
\item \href{#method-shared_features}{\code{FeatureTable$shared_features()}}
\item \href{#method-keep_shared_features}{\code{FeatureTable$keep_shared_features()}}
\item \href{#method-shared_feature_names}{\code{FeatureTable$shared_feature_names()}}
\item \href{#method-core_microbiome}{\code{FeatureTable$core_microbiome()}}
\item \href{#method-as_phyloseq}{\code{FeatureTable$as_phyloseq()}}
\item \href{#method-is_count_table}{\code{FeatureTable$is_count_table()}}
\item \href{#method-replace_zeros}{\code{FeatureTable$replace_zeros()}}
\item \href{#method-clr}{\code{FeatureTable$clr()}}
\item \href{#method-pca_biplot}{\code{FeatureTable$pca_biplot()}}
\item \href{#method-plot}{\code{FeatureTable$plot()}}
\item \href{#method-clone}{\code{FeatureTable$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Create a new FeatureTable object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$new(
  feature_table,
  feature_data = NULL,
  sample_data = NULL,
  feature_table_rows_are_samples = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{feature_table}}{Feature table, count table, or something similar.}

\item{\code{feature_data}}{Feature data (data about the features).}

\item{\code{sample_data}}{Sample/observation data (data about the samples/observations).}

\item{\code{feature_table_rows_are_samples}}{Are the rows of the feature_table samples/observations?}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new `FeatureTable` object.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{count_table <- matrix(
  c(
    0, 0, 0, 1, 10,
    0, 0, 1, 2, 20,
    0, 1, 2, 3, 30,
    1, 2, 3, 4, 40
  ),
  byrow = TRUE,
  nrow = 4,
  ncol = 5,
  dimnames = list(Samples = paste0("Sample_", 1:4),
                  Features = paste0("Feature_", 1:5))
)

feature_data <- data.frame(
  Color = c("red", "red", "red", "blue", "blue"),
  Shape = c("square", "circle", "square", NA, "circle"),
  Length = c(5, 6, 2.3, 7, 10),
  row.names = paste0("Feature_", 1:5),
  stringsAsFactors = TRUE
)

sample_data <- data.frame(
  Location = c("Spain", "Spain", "Portugal", "Spain"),
  Season = c("Summer", "Summer", "Winter", "Winter"),
  SnazzyFactor = c(10, 12, 25, 3),
  row.names = paste0("Sample_", 1:4),
  stringsAsFactors = TRUE
)

FeatureTable$new(count_table,
                 feature_data = feature_data,
                 sample_data = sample_data)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-print"></a>}}
\if{latex}{\out{\hypertarget{method-print}{}}}
\subsection{Method \code{print()}}{
Print FeatureTable
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$print(...)}\if{html}{\out{</div>}}
}

\subsection{Details}{
Prints \code{self} and returns it invisibly (via \code{invisible(self)}).
}

\subsection{Returns}{
\code{invisible(self)}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# `lee` is a dataset included in the FeatureTable package.
featuretable::lee$print()
# it would print out something like this:
# FeatureTable:
#   data         -- 16 samples, 1490 features
#   feature_data -- 7 covariates
#   sample_data  -- 4 covariates

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-dim"></a>}}
\if{latex}{\out{\hypertarget{method-dim}{}}}
\subsection{Method \code{dim()}}{
Return the dimensions of the FeatureTable \code{data} field.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$dim()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
The dimension of the feature_table.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{ft <- FeatureTable$new(matrix(1:12, 3, 4))
stopifnot(ft$dim() == 12)
stopifnot(ft$nrow() == 3)
stopifnot(ft$ncol() == 4)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-nrow"></a>}}
\if{latex}{\out{\hypertarget{method-nrow}{}}}
\subsection{Method \code{nrow()}}{
See \code{FeatureTable$dim()}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$nrow()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-ncol"></a>}}
\if{latex}{\out{\hypertarget{method-ncol}{}}}
\subsection{Method \code{ncol()}}{
See \code{FeatureTable$dim()}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$ncol()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-max"></a>}}
\if{latex}{\out{\hypertarget{method-max}{}}}
\subsection{Method \code{max()}}{
Get the minimum, maximum, size, and other features of the FeatureTable \code{data} field.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$max(...)}\if{html}{\out{</div>}}
}

\subsection{Details}{
\code{non_zero_min} returns the smallest non-zero number in the \code{data} field.  If any of the values in the \code{data} field are less than zero, then a warning will be given.  In this case, you probably don't want to use \code{non_zero_min}.
}

\subsection{Returns}{
The min (\code{min}), non-zero min (\code{non_zero_min}), and max (\code{max}) values.  \code{size} returns the number of elements in the \code{data} field (i.e., \code{nrow * ncol} for the \code{data} field).
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{ft <- FeatureTable$new(matrix(0:8, 3, 3))
stopifnot(ft$min() == 0)
stopifnot(ft$non_zero_min() == 1)
stopifnot(ft$max() == 8)
stopifnot(ft$size() == 9)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-min"></a>}}
\if{latex}{\out{\hypertarget{method-min}{}}}
\subsection{Method \code{min()}}{
See \code{FeatureTable$max()}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$min(...)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-non_zero_min"></a>}}
\if{latex}{\out{\hypertarget{method-non_zero_min}{}}}
\subsection{Method \code{non_zero_min()}}{
See \code{FeatureTable$max()}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$non_zero_min(...)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-size"></a>}}
\if{latex}{\out{\hypertarget{method-size}{}}}
\subsection{Method \code{size()}}{
See \code{FeatureTable$max()}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$size(...)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-num_samples"></a>}}
\if{latex}{\out{\hypertarget{method-num_samples}{}}}
\subsection{Method \code{num_samples()}}{
Return the number of samples/observations/rows in the FeatureTable.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$num_samples()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
The number of samples/observations/rows in the FeatureTable.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-nsamples"></a>}}
\if{latex}{\out{\hypertarget{method-nsamples}{}}}
\subsection{Method \code{nsamples()}}{
Alias of \code{FeatureTable$num_samples()}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$nsamples()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-num_observations"></a>}}
\if{latex}{\out{\hypertarget{method-num_observations}{}}}
\subsection{Method \code{num_observations()}}{
Alias of \code{FeatureTable$num_samples()}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$num_observations()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-nobservations"></a>}}
\if{latex}{\out{\hypertarget{method-nobservations}{}}}
\subsection{Method \code{nobservations()}}{
Alias of \code{FeatureTable$num_samples()}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$nobservations()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-num_features"></a>}}
\if{latex}{\out{\hypertarget{method-num_features}{}}}
\subsection{Method \code{num_features()}}{
Return the number of features/columns in the FeatureTable.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$num_features()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
The number of features/columns in the FeatureTable.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-nfeatures"></a>}}
\if{latex}{\out{\hypertarget{method-nfeatures}{}}}
\subsection{Method \code{nfeatures()}}{
Alias of \code{FeatureTable$num_features()}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$nfeatures()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-sample_names"></a>}}
\if{latex}{\out{\hypertarget{method-sample_names}{}}}
\subsection{Method \code{sample_names()}}{
Return the names of samples/observations/rows in the FeatureTable.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$sample_names()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
The names of samples/observations/rows in the FeatureTable.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-observation_names"></a>}}
\if{latex}{\out{\hypertarget{method-observation_names}{}}}
\subsection{Method \code{observation_names()}}{
Alias of \code{FeatureTable$sample_names()}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$observation_names()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-feature_names"></a>}}
\if{latex}{\out{\hypertarget{method-feature_names}{}}}
\subsection{Method \code{feature_names()}}{
Return the names of samples/observations/rows in the FeatureTable.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$feature_names()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
The names of samples/observations/rows in the FeatureTable.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-apply"></a>}}
\if{latex}{\out{\hypertarget{method-apply}{}}}
\subsection{Method \code{apply()}}{
Apply functions over FeatureTable data margins.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$apply(margin, fn, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{margin}}{A vector giving the subscripts which the function will be
applied over.  See \code{link{apply}} for details.}

\item{\code{fn}}{The function to be applied.  See \code{link{apply}} for details.}

\item{\code{...}}{Optional arguments to \code{fn}.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
This method uses \code{base::apply} to "apply" functions on to the
\code{data} field of the \code{FeatureTable}.

For details about \code{base::apply}, see \code{\link{apply}}.
}

\subsection{Returns}{
A vector or array or list of values obtained by applying a function to
margins of an array or matrix.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{# `ft` is a dataset included in FeatureTable.
#
# The apply method is a convenience wrapper around `base::apply`.
stopifnot(
  featuretable::ft$apply(2, sum) == apply(featuretable::ft$data, 2, sum)
)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-apply_with_index"></a>}}
\if{latex}{\out{\hypertarget{method-apply_with_index}{}}}
\subsection{Method \code{apply_with_index()}}{
Apply functions over FeatureTable data margins.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$apply_with_index(margin, fn, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{margin}}{A vector giving the subscripts which the function will be
applied over.  See \code{link{apply}} for details.}

\item{\code{fn}}{The function to be applied.  See \code{\link{apply}}. Note that
this one is a bit different from \code{base::apply}'s \code{FUN} in
that it should take \code{data} and an \code{index}.  See \code{Examples}
for details.}

\item{\code{...}}{Optional arguments to \code{fn}.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
This method uses \code{base::apply} to "apply" functions on to the
\code{data} field of the \code{FeatureTable}.  This method will also
provide the current \code{index} to the applied function (\code{fn}).

For details about \code{base::apply}, see \code{\link{apply}}.
}

\subsection{Returns}{
A vector or array or list of values obtained by applying a function to
margins of an array or matrix.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{ft <- featuretable::ft

# `apply_with_index` takes a function of two or more arguments, the first is the data you're working on, the second is the index of that data (e.g., row or column number), and then any other arguments are additional.
ft$apply_with_index(2, function(x, i) sum(x))

# This could of course be written as
ft$apply(2, sum)

stopifnot(
  ft$apply_with_index(2, function(x, i) sum(x)) ==
    ft$apply(2, sum)
)

# But that's a boring example.  Say you had a vector of lengths, one for
# each feature.
lengths <- c(10, 15, 12, 25, 13)

# Now you could weight the sum by the length of that feature.
ft$apply_with_index(2, function(feature, index) {
  sum(feature) / lengths[[index]]
})

# This data (`ft`) happens to have a `Length` column in the `feature_data`
# field.  Let's use that instead.
ft$apply_with_index(2, function(feature, index) {
  sum(feature) / ft$featue_data$Length[[index]]
})

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-apply_with_name"></a>}}
\if{latex}{\out{\hypertarget{method-apply_with_name}{}}}
\subsection{Method \code{apply_with_name()}}{
Similar to \code{apply_with_index}, except that \code{fn} takes a
(row or column) \code{name} rather than an \code{index}.

See \code{FeatureTable$apply_with_index} for details.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$apply_with_name(margin, fn, ...)}\if{html}{\out{</div>}}
}

\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{ft <- featuretable::ft

# Unlike `apply_with_index`, `fn` takes a name.  Its usage is similar.
ft$apply_with_name(2, function(feature, name) {
  sum(feature) / ft$feature_data[name, "Length"]
})
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-apply_features"></a>}}
\if{latex}{\out{\hypertarget{method-apply_features}{}}}
\subsection{Method \code{apply_features()}}{
Convenience wrapper for \code{FeatureTable$apply(2, fn, ...)}.

See \code{FeatureTable$apply}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$apply_features(fn, ...)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-apply_features_with_index"></a>}}
\if{latex}{\out{\hypertarget{method-apply_features_with_index}{}}}
\subsection{Method \code{apply_features_with_index()}}{
Convenience wrapper for \code{FeatureTable$apply_with_index(2, fn, ...)}.

See \code{FeatureTable$apply_with_index}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$apply_features_with_index(fn, ...)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-apply_features_with_name"></a>}}
\if{latex}{\out{\hypertarget{method-apply_features_with_name}{}}}
\subsection{Method \code{apply_features_with_name()}}{
Convenience wrapper for \code{FeatureTable$apply_with_name(2, fn, ...)}.

See \code{FeatureTable$apply_with_name}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$apply_features_with_name(fn, ...)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-apply_samples"></a>}}
\if{latex}{\out{\hypertarget{method-apply_samples}{}}}
\subsection{Method \code{apply_samples()}}{
Convenience wrapper for \code{FeatureTable$apply(1, fn, ...)}.

See \code{FeatureTable$apply}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$apply_samples(fn, ...)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-apply_samples_with_index"></a>}}
\if{latex}{\out{\hypertarget{method-apply_samples_with_index}{}}}
\subsection{Method \code{apply_samples_with_index()}}{
Convenience wrapper for \code{FeatureTable$apply_with_index(1, fn, ...)}.

See \code{FeatureTable$apply_with_index}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$apply_samples_with_index(fn, ...)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-apply_samples_with_name"></a>}}
\if{latex}{\out{\hypertarget{method-apply_samples_with_name}{}}}
\subsection{Method \code{apply_samples_with_name()}}{
Convenience wrapper for \code{FeatureTable$apply_with_name(1, fn, ...)}.

See \code{FeatureTable$apply_with_name}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$apply_samples_with_name(fn, ...)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-map"></a>}}
\if{latex}{\out{\hypertarget{method-map}{}}}
\subsection{Method \code{map()}}{
Returns a new FeatureTable by applying a function to margins of the
\code{$data} field of a \code{FeatureTable}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$map(margin, fn, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{margin}}{Margin to apply the function over.  E.g., \code{1} or
\code{"samples"} indicates rows, \code{2} or \code{"features"} indicates
columns.}

\item{\code{fn}}{The function to be applied over the specified margin.  For the
\code{map_with_*} variants, the function should have at least 2 parameters,
the data to be applied over, and the \code{name} or \code{index} of the
current row or column.  See details.}

\item{\code{...}}{Optional arguments to \code{fn}.}

\item{\code{ft}}{A FeatureTable. (only needed in the \code{S3} version)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new FeatureTable with the result of applying \code{fn} over
  \code{margin}.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{data(ft)

## Using R6 methods

# Map over features
ft$map("features", function(feature) feature / sum(feature))

# Map over samples
ft$map("samples", function(sample) sample / sum(sample))

## Using s3 methods

# Map over features
map(ft, "features", function(feature) feature / sum(feature))

# Map over samples
map(ft, "samples", function(sample) sample / sum(sample))

#### map_with_index

# Make up some fake lengths for the features.
lengths <- 1:ft$num_features()

# Map over features using the index to divide the feature by its length.
ft$map_with_index("features", function(feature, index) feature / lengths[[index]])

# And of course, the s3 function is also available!
map_with_index(ft, "features", function(feature, index) feature / lengths[[index]])

#### map_with_name

# This FeatureTable includes a \code{Length} variable in the \code{feature_data}.
#
# You can access it like this:
ft$feature_data$Length

# Let's say you want to divide the count of each feature by its length.
#
# To get easy access to that data, you can use map_with_name like so:
ft$map_with_name("features", function(feature, name) {
  feature_length <- ft$feature_data[name, "Length"]

  # Some features have an NA for length, so just set those to 1.
  feature_length <- ifelse(is.na(feature_length), 1, feature_length)

  feature / feature_length
})

# And of course, the s3 function is also available!
map_with_name(ft, "features", function(feature, name) {
  feature_length <- ft$feature_data[name, "Length"]

  # Some features have an NA for length, so just set those to 1.
  feature_length <- ifelse(is.na(feature_length), 1, feature_length)

  feature / feature_length
})

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-map_with_index"></a>}}
\if{latex}{\out{\hypertarget{method-map_with_index}{}}}
\subsection{Method \code{map_with_index()}}{
Like \code{FeatureTable$map()} but also passes the \code{index} to
\code{fn} similar to \code{FeatureTable$apply_with_index()}.

See \code{FeatureTable$map()}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$map_with_index(margin, fn, ...)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-map_with_name"></a>}}
\if{latex}{\out{\hypertarget{method-map_with_name}{}}}
\subsection{Method \code{map_with_name()}}{
Like \code{FeatureTable$map()} but also passes the \code{name} to
\code{fn} similar to \code{FeatureTable$apply_with_name()}.

See \code{FeatureTable$map()}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$map_with_name(margin, fn, ...)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-map_features"></a>}}
\if{latex}{\out{\hypertarget{method-map_features}{}}}
\subsection{Method \code{map_features()}}{
Convenience wrapper for \code{FeatureTable$map(2, fn, ...)}.

See \code{FeatureTable$map}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$map_features(fn, ...)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-map_features_with_index"></a>}}
\if{latex}{\out{\hypertarget{method-map_features_with_index}{}}}
\subsection{Method \code{map_features_with_index()}}{
Convenience wrapper for \code{FeatureTable$map_with_index(2, fn, ...)}.

See \code{FeatureTable$map}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$map_features_with_index(fn, ...)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-map_features_with_name"></a>}}
\if{latex}{\out{\hypertarget{method-map_features_with_name}{}}}
\subsection{Method \code{map_features_with_name()}}{
Convenience wrapper for \code{FeatureTable$map_with_name(2, fn, ...)}.

See \code{FeatureTable$map}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$map_features_with_name(fn, ...)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-map_samples"></a>}}
\if{latex}{\out{\hypertarget{method-map_samples}{}}}
\subsection{Method \code{map_samples()}}{
Convenience wrapper for \code{FeatureTable$map(1, fn, ...)}.

See \code{FeatureTable$map}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$map_samples(fn, ...)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-map_samples_with_index"></a>}}
\if{latex}{\out{\hypertarget{method-map_samples_with_index}{}}}
\subsection{Method \code{map_samples_with_index()}}{
Convenience wrapper for \code{FeatureTable$map_with_index(1, fn, ...)}.

See \code{FeatureTable$map}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$map_samples_with_index(fn, ...)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-map_samples_with_name"></a>}}
\if{latex}{\out{\hypertarget{method-map_samples_with_name}{}}}
\subsection{Method \code{map_samples_with_name()}}{
Convenience wrapper for \code{FeatureTable$map_with_name(1, fn, ...)}.

See \code{FeatureTable$map}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$map_samples_with_name(fn, ...)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-collapse"></a>}}
\if{latex}{\out{\hypertarget{method-collapse}{}}}
\subsection{Method \code{collapse()}}{
Collapse samples/observations/rows or features/columns based on metadata. For
features/samples, any feature/sample with the same metadata for selected
category will be grouped.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$collapse(margin, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{margin}}{Margin to collapse.  E.g., \code{1} or \code{"samples"}
indicates rows, \code{2} or \code{"features"} indicates columns.}

\item{\code{ft}}{A FeatureTable. (Only used in the \code{S3} version.)}

\item{\code{by}}{The data column to collapse by.}

\item{\code{keep_na}}{Do you want to group all NAs together (TRUE) or drop them
(FALSE, the defult)?}

\item{\code{keep_hierarchy}}{Do you want to keep all data above the level specified
with the \code{by} argument? Pass \code{TRUE} to this parameter if you
know some of your data is hierarchical and you want to treat it as such.
See vignettes for details.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Grouping is done by summing counts for each category.

If you to keep features/samples with \code{NA} for the \code{by} category,
pass \code{keep_na = TRUE}.  Then the NA will become a new factor in the
collapsed data.

Currently, you can only collapse on one metadata column at a time :(
}

\subsection{Returns}{
A new FeatureTable with the specified margin collapsed on the
  specified metadata column.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{data(ft)

# You can direcctly access variables in the metadata.
ft$collapse("features", Color)
ft$collapse_features(Color)

# Or refer to them by strings.
ft$collapse("features", "Color")
ft$collapse_features("Color")

# You can collapse samples on metadata as well.
ft$collapse("samples", Location)
ft$collapse_samples(Location)

# And you can use the s3 style functions.
collapse(ft, "samples", Location)
collapse_samples(ft, Location)

collapse(ft, "features", Shape)
collapse_features(ft, Shape)

# For now, you can't do more than one variable at a time.  Sorry!
\dontrun{
  ft$collapse_samples(c("Location", "Season"))
}

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-collapse_features"></a>}}
\if{latex}{\out{\hypertarget{method-collapse_features}{}}}
\subsection{Method \code{collapse_features()}}{
Convenience wrapper for \code{FeatureTable$collapse("features", fn, ...)}.

See \code{FeatureTable$collapse}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$collapse_features(by, keep_na = FALSE, keep_hierarchy = FALSE)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-collapse_samples"></a>}}
\if{latex}{\out{\hypertarget{method-collapse_samples}{}}}
\subsection{Method \code{collapse_samples()}}{
Convenience wrapper for \code{FeatureTable$collapse("samples", fn, ...)}.

See \code{FeatureTable$collapse}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$collapse_samples(by, keep_na = FALSE, keep_hierarchy = FALSE)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-keep"></a>}}
\if{latex}{\out{\hypertarget{method-keep}{}}}
\subsection{Method \code{keep()}}{
Keep samples/observations/rows or features/columns based on result of a
predicate function or expression.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$keep(margin, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{margin}}{Margin to apply the predicate over.  E.g., \code{1} or
\code{"samples"} indicates rows, \code{2} or \code{"features"} indicates
columns.}

\item{\code{...}}{Optional arguments to \code{predicate} if \code{predicate} is a
function.  If it is something like \code{Location == "Spain"}, then
optional arguments will be ignored.}

\item{\code{ft}}{A FeatureTable. (only used in the \code{S3} version)}

\item{\code{predicate}}{The predicate function or expression to be applied.  Only
those elements where \code{predicate} is \code{TRUE} or evaluates to
\code{TRUE} will be kept.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
A \code{predicate} can be a function that evaluates to \code{TRUE}, or
\code{FALSE} for each item it is applied to, or it can be a logical vector
the same length as the \code{margin} you're working with, or it can be some
other expresssion/call that will evaluate to a logical vector.  See Examples
for more information.

Note that `query` is currently only available for filtering features.  See
Examples for details.
}

\subsection{Returns}{
A new FeatureTable with the elements that were kept.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{data(ft)

#### Filtering based on metadata ####

# First, let me show you how to filter based on metadata (i.e., the stuff in
# `$feature_data` or `$sample_data`).  Note that this kind of filtering works
# the same for samples.

# Here is what the `feature_data` looks like.
#
# > ft$feature_data
#           Color  Shape Length
# Feature_1   red square    5.0
# Feature_2   red circle    6.0
# Feature_3   red square    2.3
# Feature_4  blue   <NA>    7.0
# Feature_5  blue circle   10.0

# To keep features, you can use either `keep` and specify the correct margin,
# or use the `keep_features` helper function.  For the examples that follow,
# I will show you both ways, but of course, you can pick whichever one you
# prefer!

# Also note that whenever you see something with the R6 calling convention:
# E.g., ft$keep("features", ...), feel free to use the S3 calling convention
# instead: keep(ft, "features", ...).

# Keep features that have 'circle' in the `feature_data`.  Note that you can
# refer to variables/colnames in the data directly inside the `keep`
# functions!
#
ft$keep("features", Shape == "circle")
ft$keep_features(Shape != "circle")

# You can use a logical vector directly.
#
ft$keep("features", c(TRUE, TRUE, FALSE, TRUE, TRUE))
ft$keep_features(c(TRUE, TRUE, FALSE, TRUE, TRUE))

# Or you can use any expressions that will evaluate to a logical vector.
#
ft$keep("features", ft$feature_data$Shape == "circle")
ft$keep_features(ft$feature_data$Shape == "circle")

# Keep features that do NOT have 'circle' in the `feature_data`.
#
ft$keep("features", Shape != "circle")
ft$keep_features(Shape != "circle")

# You can also have more complicated expressions for predicates.
#
# Keep the red circles
ft$keep("features", Shape == "circle" & Color == "red")
ft$keep_features(Shape == "circle" & Color == "red")

# Keep any features that are 'red' OR 'circles'.
ft$keep("features", Shape == "circle" | Color == "red")
ft$keep_features(Shape == "circle" | Color == "red")

# Of course, you can keep adding on expressions....
ft$keep("features", (Shape == "square" & Color == "red") | Length > 5)
ft$keep_features((Shape == "square" & Color == "red") | Length > 5)

#### Filtering based on actual data (i.e., in `$data`) ####

# Sometimes you want to filter features or samples based on the actual data
# (i.e., the stuff in `$data`), rather than on the metadata (i.e., the stuff
# in `$feature_data` or `$sample_data`).  No problem!  For that, we will use
# functions that apply over the margin we want.

# For reference, here is the data:
#
# > ft$data
#           Features
# Samples    Feature_1 Feature_2 Feature_3 Feature_4 Feature_5
#   Sample_1         0         0         0         1        10
#   Sample_2         0         0         1         2        20
#   Sample_3         0         1         2         3        30
#   Sample_4         1         2         3         4        40

# Keep features whose sum is more than 5.
ft$keep("features", function(feature) sum(feature) > 5)
ft$keep_features(function(feature) sum(feature) > 5)

# Keep samples whose sum is more than 25.
ft$keep("samples", function(sample) sum(sample) > 5)
ft$keep_samples(function(sample) sum(sample) > 5)

# Note that there is nothing special about using `sample` or `feature` as a
# parameter to those anonymous functions.  I could have used `x` or anything
# else.

#### Predicates that work on data and metadata together! ####

# What if you want to filter based on both metadata and the actual data?
# For that, you need to use `query`.  It is a special function only
# accessible from inside the keep functions. (Note that currently, you can
# only use `query` from `keep` with margin 'features', or keep_features.)

# Keep features that are circles and also have an abundance of > 5.
ft$keep("features",
        query(Shape == "circle") & query(function(feature) sum(feature) > 5))
ft$keep_features(
  query(Shape == "circle") & query(function(feature) sum(feature) > 5)
)

# Notice how I wrapped both expressions in a `query` function.  You can also
# have more than two queries just like before.

# One slightly weird thing is that the expression that evalautes w.r.t. the
# metadata doesn't actually need to be wrapped in a query.  For example, this
# will also work:
#
ft$keep_features(
  Shape == "circle" & query(function(feature) sum(feature) > 5)
)

# But I would consider that a quirk of the implementation and not rely on it,
# as it may change in the future.

#### Filtering on actual data, feature data, and sample data together ####

# For reference, here is the sample data:
# > ft$sample_data
#           Location Season SnazzyFactor
#  Sample_1    Spain Summer           10
#  Sample_2    Spain Summer           12
#  Sample_3 Portugal Winter           25
#  Sample_4    Spain Winter            3

# (Note that like the above section, this only works for features currently.)
#
# Here's something cool.  Let's say you wanted to filter features based on
# their abundance, some bit of metadata about them (e.g., taxonomy) but
# restrict your search to a subset of samples (say, all samples from Summer,
# or all samples from Spain).  You can do that with the `query` function as
# well!  Let me show you what I mean....

# Keep features whose abundance is > 5 in 'Winter' samples (i.e., you don't
# care what there abundance in other seasons, as long as they fit the
# criteria for the 'Winter' samples.)

ft$keep("features", query(function(feature) sum(feature) > 5,
                          restrict = Season == "Winter"))

# Notice the use of the `restrict` parameter.  It takes expressions that
# evaluate in the context of the sample data.

# And you can make more complicated queries if you want.
ft$keep_features(query(Shape == "circle") |
                   query(function(feature) sum(feature) > 5,
                         restrict = Season == "Winter"))

# Here is something that may trip you up.

\dontrun{
  ft$keep_features(query(Shape == "circle", restrict = Season == "Winter"))
}

# The above code will raise an `ArgumentError`.  Here's the thing: feature
# metadata does not change based on the sample metadata.  In other words, a
# feature is a 'circle' or a 'square' regardless of whether it is in a
# 'Summer' sample, a 'Winter' sample, or both.  So restricting a metadata
# query to a subset of samples just doesn't make any sense.
#
# If you find yourself wanting to do that, my guess is what you really want
# are to filter features whose 'Shape' is 'circle' and that are actually
# present in 'Winter' samples.  If that is the case, you want to do something
# like this:
#
ft$keep_features(
  query(Shape == "circle") &
    query(function(feature) sum(feature) > 0,
          restrict = Season == "Winter")
)

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-keep_features"></a>}}
\if{latex}{\out{\hypertarget{method-keep_features}{}}}
\subsection{Method \code{keep_features()}}{
Convenience wrapper for \code{FeatureTable$keep("features", fn, ...)}.

See \code{FeatureTable$keep}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$keep_features(predicate, ...)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-keep_samples"></a>}}
\if{latex}{\out{\hypertarget{method-keep_samples}{}}}
\subsection{Method \code{keep_samples()}}{
Convenience wrapper for \code{FeatureTable$keep("samples", fn, ...)}.

See \code{FeatureTable$keep}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$keep_samples(predicate, ...)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-shared_features"></a>}}
\if{latex}{\out{\hypertarget{method-shared_features}{}}}
\subsection{Method \code{shared_features()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$shared_features(method, other)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-keep_shared_features"></a>}}
\if{latex}{\out{\hypertarget{method-keep_shared_features}{}}}
\subsection{Method \code{keep_shared_features()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$keep_shared_features(other)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-shared_feature_names"></a>}}
\if{latex}{\out{\hypertarget{method-shared_feature_names}{}}}
\subsection{Method \code{shared_feature_names()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$shared_feature_names(other)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-core_microbiome"></a>}}
\if{latex}{\out{\hypertarget{method-core_microbiome}{}}}
\subsection{Method \code{core_microbiome()}}{
Core Microbiome
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$core_microbiome(
  detection_limit = 1,
  min_sample_proportion = NULL,
  max_sample_proportion = NULL,
  min_samples = NULL,
  max_samples = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{detection_limit}}{Limit of detection for a feature to be considered
present in a sample}

\item{\code{min_sample_proportion}}{Minimum proportion of samples in which a feature
must be present to be kept.}

\item{\code{max_sample_proportion}}{Maximum proportion of samples in which a feature
must be present to be kept.}

\item{\code{min_samples}}{Minimum number of samples in which a feature must be
present to be kept.}

\item{\code{max_samples}}{Maximum number of samples in which a feature must be
present to be kept.}

\item{\code{ft}}{A FeatureTable}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
If both \code{min_sample_proportion} and \code{min_samples} are given, an
  error will be raised. If \code{min_sample_proportion} is not a proportion,
  an error will be raised.  If \code{min_samples} looks like a proportion, a
   warning will be given.
}

\subsection{Returns}{
A new FeatureTable with only the specified "core" features.
Convert FeatureTable to phyloseq object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-as_phyloseq"></a>}}
\if{latex}{\out{\hypertarget{method-as_phyloseq}{}}}
\subsection{Method \code{as_phyloseq()}}{
If the 'phyloseq' package is not installed, it raises an Error.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$as_phyloseq()}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{ft}}{A FeatureTable}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
a phyloseq object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-is_count_table"></a>}}
\if{latex}{\out{\hypertarget{method-is_count_table}{}}}
\subsection{Method \code{is_count_table()}}{
Is the FeatureTable a count table?
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$is_count_table()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
TRUE if \code{feature_table} contains only natural numbers (counting numbers >= 0), FALSE otherwise.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-replace_zeros"></a>}}
\if{latex}{\out{\hypertarget{method-replace_zeros}{}}}
\subsection{Method \code{replace_zeros()}}{
Replacing zeros.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$replace_zeros(
  replacement = 0.05,
  tol = .Machine$double.eps^0.5,
  use_cmultRepl = FALSE,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{replacement}}{(Ignored if \code{use_cmultRepl = TRUE})}

\item{\code{tol}}{(Ignored if \code{use_cmultRepl = TRUE})}

\item{\code{use_cmultRepl}}{TRUE/FALSE whether to use \code{cmultRepl} function.}

\item{\code{...}}{Extra arguments (i.g., passed to \code{cmultRepl})}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
If \code{use_cmultRepl = TRUE} but \code{zCompositions::cmultRepl} is not
availabel, it will raise an error.
}

\subsection{Returns}{
A new FeatureTable with the zeros in \code{data} replaced.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clr"></a>}}
\if{latex}{\out{\hypertarget{method-clr}{}}}
\subsection{Method \code{clr()}}{
Centered log ratio.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$clr(base = 2)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{base}}{Base of logarithm.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
See
\url{https://en.wikipedia.org/wiki/Compositional_data#Center_logratio_transform}.
}

\subsection{Returns}{
A FeatureTable with the \code{data} transformed with centered log ratio.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-pca_biplot"></a>}}
\if{latex}{\out{\hypertarget{method-pca_biplot}{}}}
\subsection{Method \code{pca_biplot()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$pca_biplot(use_biplotr = FALSE, include_sample_data = FALSE, ...)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-plot"></a>}}
\if{latex}{\out{\hypertarget{method-plot}{}}}
\subsection{Method \code{plot()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$plot(
  num_features = 8,
  other_feature_name = "Other",
  fill = TRUE,
  palette = "kelly",
  show_legend = TRUE,
  legend_title = NULL,
  plot_title = NULL,
  xlab = NULL,
  ylab = NULL,
  axis.text.x = NULL,
  ...
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{FeatureTable$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
